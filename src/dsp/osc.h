#ifndef DSP_OSC_H
#define DSP_OSC_H 1

#include "dsp/func.h"

typedef struct { double phase; } PHASOR;

static inline double phasor(PHASOR *p, double hz) {
  return p->phase = wrap(p->phase + hz / SR);
}

#define WAVELEVELS 11

typedef struct {
  float wave[1 << (WAVELEVELS + 1)];
} WAVETABLE;

static inline void wavetable_saw(WAVETABLE *w) {
  for (int level = 0; level <= WAVELEVELS; ++level) {
    int n = 1 << level;
    int m = n >> 1;
    for (int i = 0; i < n; ++i) {
      w->wave[n + i] = 0;
      for (int k = 1; k < m; ++k) {
        double phase = twopi * ((k * i) % n) / (double) n;
        double sign = (k & 1) ? 1 : -1;
        double window = clamp(2 * (m - k) / (double) m, 0, 1);
        w->wave[n + i] += window * sign * sin(phase) / k;
      }
      w->wave[n + i] *= 2 / pi;
    }
  }
}

typedef struct {
  double phase;
} WAVE;

static inline double wave(WAVETABLE *wt, WAVE *w, double phase) {
  double delta = fabs(wrap(phase - w->phase));
  w->phase = phase;
  double l = -log2(delta);
  int l1 = floor(l);
  int l0 = l1 - 1;
  double lt = l - l1;
  l0 = clamp(l0, 0, WAVELEVELS);
  l1 = clamp(l1, 0, WAVELEVELS);
  int n0 = 1 << l0;
  int n1 = 1 << l1;
  double t = wrap(phase);
  double i0 = t * n0;
  int i00 = floor(i0);
  int i01 = (i00 + 1) % n0;
  double i0t = i0 - i00;
  double i1 = t * n1;
  int i10 = floor(i1);
  int i11 = (i10 + 1) % n1;
  double i1t = i1 - i10;
  return
    mix
    ( mix(wt->wave[n0 + i00], wt->wave[n0 + i01], i0t)
    , mix(wt->wave[n1 + i10], wt->wave[n1 + i11], i1t)
    , lt
    );
}


// <http://www.firstpr.com.au/dsp/pink-noise/>
// <http://www.firstpr.com.au/dsp/pink-noise/phil_burk_19990905_patest_pink.c>

/*
	patest_pink.c

	Generate Pink Noise using Gardner method.
	Optimization suggested by James McCartney uses a tree
	to select which random value to replace.

    x x x x x x x x x x x x x x x x
     x   x   x   x   x   x   x   x
       x       x       x       x
           x               x
                   x

    Tree is generated by counting trailing zeros in an increasing index.
	When the index is zero, no random number is selected.

    This program uses the Portable Audio library which is under development.
	For more information see:   http://www.audiomulch.com/portaudio/

    Author: Phil Burk, http://www.softsynth.com

	Revision History:

    Copyleft 1999 Phil Burk - No rights reserved.
*/

/************************************************************/
/* Calculate pseudo-random 32 bit number based on linear congruential method. */
//static unsigned long randSeed = 22222;  /* Change this for different random sequences. */
static inline unsigned long pink_GenerateRandomNumber(unsigned long randSeed) {
	randSeed = (randSeed * 196314165) + 907633515;
	return randSeed;
}

#define PINK_MAX_RANDOM_ROWS   (30)
#define PINK_RANDOM_BITS       (24)
#define PINK_RANDOM_SHIFT      ((sizeof(long)*8)-PINK_RANDOM_BITS)

typedef struct {
	long      pink_Rows[PINK_MAX_RANDOM_ROWS];
	long      pink_RunningSum;   /* Used to optimize summing of generators. */
	int       pink_Index;        /* Incremented each sample. */
	int       pink_IndexMask;    /* Index wrapped by ANDing with this mask. */
	double    pink_Scalar;       /* Used to scale within range of -1.0 to +1.0 */
  unsigned long seed;
} PINK;

/* Setup PinkNoise structure for N rows of generators. */
void pink_init(PINK *pink, int numRows, unsigned long seed)
{
	int i;
	long pmax;
	pink->pink_Index = 0;
	pink->pink_IndexMask = (1<<numRows) - 1;
/* Calculate maximum possible signed random value. Extra 1 for white noise always added. */
	pmax = (numRows + 1) * (1<<(PINK_RANDOM_BITS-1));
	pink->pink_Scalar = 1.0f / pmax;
/* Initialize rows. */
	for( i=0; i<numRows; i++ ) pink->pink_Rows[i] = 0;
	pink->pink_RunningSum = 0;
  pink->seed = seed;
}

/* Generate Pink noise values between -1.0 and +1.0 */
double pink(PINK *pink ) {
	long newRandom;
	long sum;
	double output;

/* Increment and mask index. */
	pink->pink_Index = (pink->pink_Index + 1) & pink->pink_IndexMask;

/* If index is zero, don't update any random values. */
	if( pink->pink_Index != 0 )
	{
	/* Determine how many trailing zeros in PinkIndex. */
	/* This algorithm will hang if n==0 so test first. */
		int numZeros = 0;
		int n = pink->pink_Index;
		while( (n & 1) == 0 )
		{
			n = n >> 1;
			numZeros++;
		}

	/* Replace the indexed ROWS random value.
	 * Subtract and add back to RunningSum instead of adding all the random
	 * values together. Only one changes each time.
	 */
		pink->pink_RunningSum -= pink->pink_Rows[numZeros];
		newRandom = ((long) (pink->seed = pink_GenerateRandomNumber(pink->seed))) >> PINK_RANDOM_SHIFT;
		pink->pink_RunningSum += newRandom;
		pink->pink_Rows[numZeros] = newRandom;
	}

/* Add extra white noise value. */
	newRandom = ((long) (pink->seed = pink_GenerateRandomNumber(pink->seed))) >> PINK_RANDOM_SHIFT;
	sum = pink->pink_RunningSum + newRandom;

/* Scale to range of -1.0 to 0.9999. */
	output = pink->pink_Scalar * sum;

	return output;
}


/* analogue adsr */

#define SMALL 1e-6
#define ANTIDENORMAL 1e-18

#define RELEASE 0
#define ATTACK  1
#define DECAY   2

typedef struct {
  double trigger_1;
  double peak_1;
  double peak_2;
  double threshold_1;
  double threshold_2;
  double out_1;
  double out_2;
  int phase;
} ADSR;

static inline double adsr(ADSR *adsr, double trigger, double attack, double peak, double decay, double sustain, double release, double threshold) {
  ADSR *x = adsr;
  /* restore history */
  double trigger_1   = x->trigger_1;
  double peak_1      = x->peak_1;
  double peak_2      = x->peak_2;
  double threshold_1 = x->threshold_1;
  double threshold_2 = x->threshold_2;
  double out_1       = x->out_1;
  double out_2       = x->out_2;
  int    phase       = x->phase;
  /* useful semi-constant */
  double T = -1000.0 / SR;
  /* scale milliseconds to multipliers */
  if (attack  < SMALL) { attack  = SMALL; } attack  = exp(T/attack);
  if (decay   < SMALL) { decay   = SMALL; } decay   = exp(T/decay);
  if (release < SMALL) { release = SMALL; } release = exp(T/release);
  /* which phase are we in? */
  if        (trigger - trigger_1 > 0) {
      /* rising trigger */
      phase = ATTACK;
  } else if (trigger - trigger_1 < 0) {
      /* falling trigger */
      phase = RELEASE;
  } else if ((out_1 > peak_1 * threshold_1) -
             (out_2 > peak_2 * threshold_2) > 0) {
      /* rising above peak threshold */
      phase = DECAY;
  }
  /* behaviour depends on phase */
  double target = 0, rate = 0;
  switch (phase) {
  case (ATTACK):  target = peak;    rate = attack;  break;
  case (DECAY):   target = sustain; rate = decay;   break;
  case (RELEASE): target = 0;       rate = release; break;
  default:        target = 0;       rate = 0;       break; /* never */
  }
  /* exponential decay to a target */
  double out = rate * out_1 + (1 - rate) * target;
  /* kill denormal by quantization */
  out += ANTIDENORMAL;
  out -= ANTIDENORMAL;
  /* recycle history */
  trigger_1   = trigger;
  peak_2      = peak_1;
  peak_1      = peak;
  threshold_2 = threshold_1;
  threshold_1 = threshold;
  out_2       = out_1;
  out_1       = out;
  /* save history */
  x->trigger_1   = trigger_1;
  x->peak_1      = peak_1;
  x->peak_2      = peak_2;
  x->threshold_1 = threshold_1;
  x->threshold_2 = threshold_2;
  x->out_1       = out_1;
  x->out_2       = out_2;
  x->phase       = phase;
  return out;
}

#undef SMALL
#undef ANTIDENORMAL
#undef RELEASE
#undef ATTACK
#undef DECAY

#endif
